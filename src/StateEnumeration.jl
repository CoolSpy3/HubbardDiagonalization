"Helper functions for enumerating states under various constraints"
module StateEnumeration

export color_configurations, num_configuration_permutations
export enumerate_states, enumerate_multistate

"""
	color_configurations(N_fermions::Int, num_sites::Int, num_colors::Int=num_colors)

Generate all possible distributions of `N_fermions` fermions across `num_sites` sites with `num_colors` colors,
accounting for the fact that the colors can be permuted without affecting the computed properties of the system.
That is, the configuration `[2,1,0]` is considered the same as `[1,2,0]` or `[0,1,2]` and will only be returned once.

Returns a vector of vectors, where each inner vector represents a color configuration, and each element of the inner vector
is the number of fermions of that color.
"""
function color_configurations(N_fermions::Int, num_sites::Int, num_colors::Int)
	if N_fermions == 0
		# Only one configuration: no fermions of any color
		return [zeros(Int, num_colors)]
	end
	if N_fermions > num_colors * num_sites
		# It's impossible to place this many fermions without violating the Pauli-exclusion principle (not enough color/site combinations)
		return []
	end

	if num_colors == 1
		# Only one configuration: all fermions of a single color
		return [[N_fermions]]
	end

	# No need to make this a generator, since the number of configurations is small
	# ex. for num_colors=3, num_sites=8, there are only 165 configurations
	configurations = []
	# For every possible number of fermions of the first color,
	for N_fermions_color1 in 0:min(N_fermions, num_sites)
		# Recursively get all configurations for the remaining colors and fermions
		new_configurations = color_configurations(
			# # of fermions left to place
			N_fermions - N_fermions_color1,
			# The number of sites is really an upper-bound on how many fermions of a single color can be placed
			# Thus, we can reduce the number of sites available to the remaining colors
			# to ensure that the none of them can have more fermions than the first color.
			# This ensures that we don't recount configurations which can be permuted.
			# i.e. [2,1,0] is okay, but [1,2,0] is not, because it will be counted by [2,1,0]
			# However, [8,8,0] is okay because we're iterating over the first color, so the leading 8 will not recur.
			# Similarly, [8,0,8] cannot occur because the last 8 is greater than the preceding 0.
			min(num_sites, N_fermions_color1),
			# One fewer color to place
			num_colors - 1
		)
		# Prepend the number of fermions of the first color to each configuration
		pushfirst!.(new_configurations, N_fermions_color1)
		# Add these configurations to the list
		append!(configurations, new_configurations)
	end

	return configurations
end

"""
	num_configuration_permutations(configuration::Vector{Int})

Given a color configuration (as generated by `color_configurations`), returns the number of distinct permutations
of that configuration.
For example, the configuration `[2,1,0]` has 3 distinct permutations: `[2,1,0]`, `[1,2,0]`, and `[0,2,1]`.
"""
function num_configuration_permutations(configuration::Vector{Int})
	# The fermion counts are indistinguishable, so we need to count how many of
	# each number there are in order to figure out how many times we can permute them
	number_map = Dict{Int,Int}()
	for number in configuration
		number_map[number] = get(number_map, number, 0) + 1
	end

	num_permutations = 1

	n_unassigned_slots = length(configuration)
	for (_, count) in number_map
		# For each number, choose the number of slots it occupies from the number still available
		num_permutations *= binomial(n_unassigned_slots, count)
		# Remove those slots from the available pool
		n_unassigned_slots -= count
	end

	# If all went to plan, we should have assigned all the slots
	@assert n_unassigned_slots == 0

	return num_permutations
end

"""
	enumerate_states(n_bits_total::Int, n_bits_set::Int)

Generate all bitmasks of length `n_bits_total` with exactly `n_bits_set` bits set to 1.
Returns an iterator that yields integers representing the bitmasks.
The order of the returned states is always the same.
"""
function enumerate_states(n_bits_total::Int, n_bits_set::Int)
	return StateIterator(n_bits_total, n_bits_set)
end

#region enumerate_states Implementation

struct StateIterator
	n_bits_total::Int
	n_bits_set::Int
end

function Base.iterate(iter::StateIterator)
	# Sanity check
	if iter.n_bits_set > iter.n_bits_total
		return nothing
	end
	# The first value is the lowest bitmask with the required number of bits set
	initial_value = (1 << iter.n_bits_set) - 1
	return initial_value, initial_value
end

# Gosper's Hack (i.e. magic)
# https://rosettacode.org/wiki/Gosper%27s_hack#Julia
function Base.iterate(iter::StateIterator, last_value::Int)
	if last_value == 0
		return nothing
	end
	c = last_value & -last_value
	r = last_value + c
	if r >= (1 << iter.n_bits_total)
		return nothing
	end
	new_state = (((r โป last_value) >> 2) รท c) | r
	return new_state, new_state
end

#endregion

"""
	enumerate_multistate(n_sites::Int, n_fermions::Vector{Int})

Generate all combinations of states for multiple colors of fermions where the
number of fermions of each color is fixed.
`n_sites` is the number of sites in the system.
`n_fermions` is a vector where each element is the number of fermions of that color.
Returns an iterator that yields vectors of integers, where each integer is a bitmask
representing the state of that color.
The order of the returned states is always the same.
"""
function enumerate_multistate(n_sites::Int, n_fermions::Vector{Int})
	# We can piggyback off of the fact that enumerate_states returns all the possible
	# states for a single color (with a fixed number of fermions).
	# Thus, we can just create one of those for each color, and pass in the max that we were given.
	return MultiStateIterator(n_sites, n_fermions, [enumerate_states(n_sites, n) for n in n_fermions])
end

#region enumerate_multistate Implementation

struct MultiStateIterator
	n_sites::Int
	n_fermions::Vector{Int}
	iterators::Vector{StateIterator}
end

function Base.iterate(iter::MultiStateIterator)
	# Sanity check
	if sum(iter.n_fermions)  > iter.n_sites * length(iter.n_fermions)
		return nothing
	end
	# Initialize all the iterators
	states = [first(iterate(it)) for it in iter.iterators]
	# Because enumerate_states is always seeded with it's previous value, we can just
	# return the states as both the value and the state. However, if we were to use
	# an arbitrary iterator, we'd have to calculate last(iterate(it)).
	return states, states
end

function Base.iterate(iter::MultiStateIterator, last_states::Vector{Int})
	state_iterators = iter.iterators
	# Starting at the first state,
	for i in 1:length(last_states)
		# Try to advance the state
		next_state = iterate(state_iterators[i], last_states[i])
		if next_state !== nothing
			# If successful, continue
			last_states[i] = first(next_state)
			return last_states, last_states  # See note about return value in iterate(iter) implementation
		else
			# Otherwise, we've iterated over all the states for this color
			# Reset this color and try iterating the next one
			last_states[i] = first(iterate(state_iterators[i]))
		end
	end
	# If all the colors are exhausted, we're done
	return nothing
end

#endregion

end
